# Objects

Objects, short for object tokens, are a new kind of NFT.

Traditional NFTs rely on an external metadata URI, leaving their structure opaque onchain. Object tokens embed a compact descriptor—a small struct with their kind, set, and revision—making their identity directly visible onchain.

For clarity, this documentation uses **OBTs** to denote object tokens and **OPTs** to denote traditional NFTs.

## Properties

The table below outlines the key properties tracked by token contracts of OPTs and OBTs.

| Property       | Description                                                        | OPT | OBT |
|----------------|--------------------------------------------------------------------|-----|-----|
| **id**         | Unique identifier within a set (non-fungible only)                 | ✓   | ✓   |
| **owner**      | Current owner of the token                                         | ✓   | ✓   |
| **balance**    | Quantity owned (for fungible / semi-fungible tokens)               | ✓   | ✓   |
| **uri**        | External metadata URI                                              | ✓   | —   |
| **descriptor** | Structured data describing an object's kind, set, and revision     | —   | ✓   |
| **elements**   | Building blocks of an object: matter, value, unique, and info      | —   | ✓   |

## Operations

The table below outlines the core operations available to OPTs and OBTs.

| Operation      | Description                                      | OPT | OBT |
|----------------|--------------------------------------------------|-----|-----|
| **transfer**   | Changes ownership of a token                     | ✓   | ✓   |
| **update**     | Modifies an object's elements                    | —   | ✓   |
| **upgrade**    | Applies a newer revision of its kind or set      | —   | ✓   |
| **relate**     | Connect an object to another                     | —   | ✓   |
| **unrelate**   | Disconnect an object from another                | —   | ✓   |

## Descriptor

A descriptor is a structured record that defines an object's kind, set, and current revision.

```solidity
struct Descriptor {
    uint32 flags; // reserved
    uint32 rev;   // current revision of the object
    uint32 krev;  // kind revision under which this object operates
    uint32 srev;  // set revision under which this object operates
    uint64 kind;  // kind ID this object belongs to
    uint64 set;   // set ID from which this object is minted
}
```

The entire descriptor fits within a single `bytes32` (256 bits).

## Elements

Elements are the building blocks of an object. There are four types: **matter**, **value**, **unique**, and **info**. These will be explained in the next chapter.

For now, each element is encoded as a `bytes32` (256 bits). All elements of an object are typically emitted as a `bytes32[]` in set contract events:

```solidity
bytes32[] elems
```

An object can have anywhere from 0 to 16 elements.

## Set Contract

The token contracts for object tokens are called **set contracts**. 

The interface of a set contract is as follows:

```solidity
interface ISet {
    event Created(uint64 id, Descriptor desc, bytes32[] elems, address owner);
    event Updated(uint64 id, Descriptor desc, bytes32[] elems);
    event Upgraded(uint64 id, Descriptor desc);
    event Touched(uint64 id, Descriptor desc);
    event Destroyed(uint64 id, Descriptor desc);
    event Transferred(uint64 id, Descriptor desc, address from, address to);

    function upgrade(uint64 id, uint32 krev0, uint32 srev0) external returns (Descriptor memory desc);
    function touch(uint64 id) external returns (Descriptor memory desc);
    function transfer(uint64 id, address to) external;

    function owner(uint64 id) external view returns (address);
    function descriptor(uint64 id, uint32 rev0) external view returns (Descriptor memory desc);
    function snapshot(uint64 id, uint32 rev0) external view returns (Descriptor memory desc, bytes32[] memory elems);
    function uri() external view returns (string memory);
}
```

## Object Assets

Assets for **OPTs** are typically hosted on distributed storage networks such as IPFS or Arweave, or sometimes even on centralized servers. This makes them either static or vulnerable to issues arising from centralized hosting (availability loss, tampering, broken links, and so on).

Assets for **OBTs** are generated onchain by executing the object’s kind contract. The contract uses the object’s descriptor and elements—along with any data shared by its kind or set—to produce the final assets.

These assets can be retrieved through an Every Network gateway. Because the computation is deterministic and publicly verifiable, any client can recompute and verify authenticity. This removes the risks of external hosting and allows assets to be used safely and trustlessly in richer applications.

The asset-producing functions in a kind contract are called **facet functions**. The table below shows a typical set of facets used to generate OPT-compatible assets:

| facet function | facet selector | facet asset URL                                    |
|----------------|----------------|----------------------------------------------------|
| **meta()**     | `0x0144b03a`   | `http://every.lo/object/31337.22.3/1/0x0144b03a` |
| **picture()**  | `0xeb0568a6`   | `http://every.lo/object/31337.22.3/1/0xeb0568a6` |

:::info
The `http://every.lo` URLs shown here are gateways for a localnet instance.  
See [endpoints](network/endpoints) for the complete list of available gateways.
:::
