Objects are the fundamental unit of Every Protocol. They extend the idea of tokens by giving them structure, semantics, and the ability to interact. This makes them more than just assets — they’re programmable, evolvable, and interoperable digital entities.

## Tokens and token contracts

The OpenZeppelin documentation[^note] explains the distinction:

> *Token contracts are smart contracts that manage token balances and operations, while tokens themselves are the digital assets represented by those balances.*

Traditional tokens maintain simple mappings like:
Every object is a token, and it is minted from a smart contract called a **set**.
Sets define minting rules, permissions, and serve as the source of truth for all objects they produce.

Like ERC721 contracts, a set can mint multiple unique tokens. But in Every Protocol, those tokens are full-featured objects with rich structure and behavior.

## Token Records Comparison

| Standard | Storage Structure | Key Features |
|----------|-------------------|-------------|
| **ERC20** | `address => balance` | Fungible tokens, simple transfers |
| **ERC721** | `tokenId => (owner, metadataURI)` | Non-fungible tokens (NFTs), unique assets |
| **ERC1155** | `(address, tokenId) => balance` | Hybrid fungible/non-fungible, batch operations |
| **Every Protocol** | `tokenId => (owner, state)` + `tokenId => position` | Structured objects with:<br>- Meta data<br>- Element components<br>- Relations<br>- Facets |

Records are composable and versioned, supporting co-creation, upgrades, and reproducible object evolution.

## Meta, elements, connections, facets

- **Meta**: standard fields like title, creator, timestamps, and tags
- **Elements**:
  - **Matter** – digital assets (e.g. image, model, code)
  - **Values** – balances of fungible tokens (like ERC20)
  - **Uniques** – ownership of specific NFTs or identifiers (like ERC721)
  - **Info** – raw or structured data blobs
- **Connections**: relations to other objects, sets, kinds, or offchain resources
- **Facets**: optional modules that describe how to display, compute, or interact with the object

## Basic operations

Objects support familiar token operations:

- **mint** – create a new object from a set
- **transfer** – move ownership
- **burn** – destroy the object (optional)
- **update** – edit or add elements (according to rules set by the kind or set)

Since objects are structured, these operations can include content updates, dependency changes, or computed mutations.

## Inter operations

Objects can also interact with one another through **relations** — kind-defined rules that describe how objects connect.

For example:

- An object can *reference* another (like a parent-child or composition)
- Objects can form *networks* (e.g. social graphs, supply chains)
- Interactions can trigger *computed updates* (e.g. combining objects, unlocking upgrades)

These interactions are native to Every Protocol, enabling secure and verifiable co-creation, remixing, and evolution across users and applications.

Let me know if you’d like this broken into smaller pages or if you want any diagrams or embedded components for Mintlify!
