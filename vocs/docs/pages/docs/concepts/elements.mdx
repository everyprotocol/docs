# Elements

Elements are the basic units that compose an object. 

There are four types: **matter**, **value**, **unique**, and **info**. All elements are stored as 32-byte values within set contracts, and some may reference additional digital content stored on the Every Network.


## Matter

**Matter** represents digital content stored on the Every Network. It can be simple—such as images, JSON data, or WASM code—or complex, such as enumerations or permutations containing rows of elements.

Each matter entry stores three fields:

| Field   | Type        | Description                        |
|---------|-------------|------------------------------------|
| `form`  | `uint8`     | The matter type                    |
| `mime`  | `string31`  | MIME type (31 bytes, right-padded) |
| `blob`  | `bytes`     | The underlying digital content     |

A matter is referenced and committed by its **hash**, ensuring its content—and any structure derived from it—is cryptographically determined. The hash is computed as:

```text
SHA256(form ++ mime ++ blob)
```

## Value

A **value** represents an amount of a fungible token wrapped inside an object.

The underlying token must be registered in the **Element Registry**, and its associated matter entries must exist on the Every Network.

A value element is stored as a `bytes32`-encoded tuple containing:

| Field    | Type      | Description                                   |
|----------|-----------|-----------------------------------------------|
| `token`  | `uint64`  | Index of the registered token                 |
| `id`     | `uint64`  | Always `0` for fungible tokens                |
| `amount` | `uint128` | Amount of tokens wrapped (max: 2¹²⁸ − 1)      |

:::info
The **set contract** is responsible for ensuring that the object is backed by the exact amount of the referenced token.
:::

:::info
Amounts use `uint128` instead of `uint256`. While `uint128` is sufficient for most practical cases, tokens with very large decimal ranges could cause overflow.
:::

## Unique

A **unique** represents an amount of OPT wrapped inside an object.

The underlying token must be registered in the **Element Registry**, and its associated matter entries must exist on the Every Network.

A unique element is stored as a `bytes32`-encoded tuple containing:

| Field    | Type      | Description                                   |
|----------|-----------|-----------------------------------------------|
| `token`  | `uint64`  | Index of the registered token                 |
| `id`     | `uint64`  | Token ID of the OPT                           |
| `amount` | `uint128` | Amount of tokens wrapped (max: 2¹²⁸ − 1)      |

:::info
The **set contract** is responsible for ensuring that the object is backed by the exact amount of the referenced token.
:::

:::info
Amounts use `uint128` instead of `uint256`. While `uint128` is sufficient for most practical cases, tokens with very large decimal ranges could cause overflow.
:::

## Info

An **info** element is an arbitrary `bytes32` value. It is used to store small pieces of data directly within an object.


## Element Registry

A **matter** element must be stored on the Every Network before it can be used to construct an object. Its matter hash can be pre-computed and referenced in the `Created` and `Updated` events emitted by a set contract.

**Info** elements have no associated digital content and require no registration; they may be referenced freely.

**Value** and **unique** elements, however, must be registered in the [Element Registry](/docs/contracts/core/ElementRegistry) before use.  
Once registered, a token index is assigned. When minting or updating an object, the set contract uses this token index to specify how much of the token or which instance is held by the object.
